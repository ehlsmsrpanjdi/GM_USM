// Memory.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int MonsterSpeed = 10;

void PlayerMove() {
    int MonsterSpeed = 3;
}
void MonsterMove();


int main()
{

    PlayerMove();
    int value = 39;
    {
        value = 20;
    }
    std::cout << value;

    

}

//
//디스크를 초기화 시킨 다음 할당되지 않은 공간의 디스크가 존재하면 새 단순 볼륨을 만들어서 이 볼륨의 용량을 선택할 수 있습니다.
//
//대부분의 프로그래밍 언어는
//객체지향을 포함했다고 한느 언어들은
//개념, 행동, 상태로 인간의 욕구를 구분한다.
//
//개념 몬스터를 만들고 싶다.
//몬스터는 움직여야한다->행동->함수
//
//스피드가 필요하다->상태가 필요하다->변수화 라는 절차적인 생각, 생성을 해야한다.
//
//
//
//변수의 첫 번째 규칙
//
//재정의 여러번 초기화했습니다.
//
//같은 이름의 변수는 같은 영역 안에 2번 선언할 수 없다.
//
//왜냐 ?
//
//램에 빚대서 생각해보자
//
//변수를 하나 만든다면
//어떠한 주소에 변수가 하나 생성되는데, 다시 재정의한다면 그 주소에 다시 변수를 하나 만들려고 하니 오류가 생김
//
//같은 이름의 변수는 메모리 영역이 겹친다.예) 96번지에 변수가 하나 생겼는데, 똑같이 96번지에 다시 변수선언하로 갔는데
//거기 이미 방이 차 있으므로 안된다.
//
//main함수에 변수를 만들 수 있다.다른 함수에도 당연히 만들 수 있다.
//그러면 만약 똑같은 이름의 변수를 서로 다른 함수에 선언했는데, 왜 에러가 나지 않느냐 ?
//
//두 가지 이유가 있는데, 함수의 메모리에 대해서 아는 것과
//변수의 생략된 앞 이름에 대해서 이해해야 합니다.
//
//main안에 있는 변수는 사실 mainvalue입니다.
//다른함수 monsterspeed의 변수는 monsterspeedvalue입니다.이런 식으로 되기 때문에, 애초에 변수의 이름이 다릅니다.
//함수의 내부에 있는 변수는 함수의 이름과 함께 해석되기에, 함수의 이름과 함께 해석된다고 생가하면 된다.
//
//메모리 영역은 코드영역, 데이터영역, 힙영역, 스택영역이 있는데,
//이것 또한 렘에 할당된 프로그램의 영역만큼 공간이 할당되어 올라가는거다.
//변수는 실행되면 스택 영역에 올라갑니다.
//함수또한 스택 영역에 올라가는데, 함수가 실행되기 위한 영역을 따로 만든다.
//Stack 영역에 main함수 영역이 생성(내부의 변수 + a정도)
//main함수에서 또 다른 함수가 실행되면 ? 스택 메모리 안에 새로운 그 함수의 영역이 생성된다.
//그러면 main함수의 영역과 새로운 함수의 영역은 애초에 다르기 때문에, 우리는 같은 이름의 변수를
//가지고 있어도 애초에 할당된 메모리 영역이 다르기 때문에, 겹칠 일이 없다.
//
//함수의{}은{ 여기부터 지역을 만들어
//}이제 지역을 끝내라
//그렇기 때문에, 함수 안에 있는 변수를 지역변수라고 부른다.
//
//함수가 실행되면 함수는 램에 자신이 실행될 지역메모리를 만들고, 그 안에 변수를 두는데
//그래서 함수 내부의 변수를 지역변수라고 부른다.스택 메모리는 뒤에서 부터 생성
//
//스코프 혹은 레인지라고 하는데
//이 두개의 구문이 함수가 실행되면 스택 영역에 이 함수의 메모리 영역을 만든다는 의미가 되고
//마무리 중괄호는 이 영역을 삭제하라는 명령이 된다.이 중괄호의 영역을 스코프라고함
//
//전역 변수 스코프({}) 에 속하지 않은 영역을 전역
//
//함수의 스코프에 속하는 영역을 지역
//
//클래스를 배우게 되면 알게될 클래스 안의 지역
//
//이때 변수는 각 영역들에 선언할 수 있는데,
//각 메모리적 영역이 다르다.
//
//함수를 만들었는데, 쓰지를 않으면 코딩 최적화에 의해서 애초에 영역에 올리지도 않는다. (지운다)
//따라서 함수가 에러가 있어도 에러가 나지 않는다.
//
//강사님's standard 생략하지 않는다. FullName이 명시적으로 존재한다면 왠만하면 FullName을 사용하려고 합니다.
//전역변수와 지역변수의 이름을 절대로 똑같이 짓지 않을 것입니다.
//예 GlobalA, LocalA
//
//코딩 스텐다드란 표기법 및 구문법을 각 상황에 맞춰서 규칙을 정한 것이고, 안지키면 살해당합니다.
//강사님은  구글 + 언리얼식으로 사용
//
//Ctrl + K + C 주석
//
//이제 전역변수에 대해서 알아보자
//전역변수라고 해서 변수의 크기가 달라지진 않는다.
//
//지역변수의 한계는 지역 변수 밖에서는 사용하지 못한다.
//어떤 지역에서 만든 변수는 다른 지역에서 사용이 불가능하다.
//그 함수의 스코프가 끝나서 함수가 종료되면 메모리에서 사라질텐데, 그러면 그 함수의 변수를 사용할 수 있다는 것 자체가
//어불성설
//
//메모리 처리가 다른 형식인 변수가 필요한데, 지역이라는 영역에 얽매이지 않는 변수가 필요하다
//이러한 변수를 전역 변수라고 한다.그리고 그러한 전역변수가 할당되는 메모리를 데이터 영역이라고 한다.
//프로세스가 종료되기 전까지 파괴되지 않는다.
//스택이 만들어지기도 전에 전역변수가 만들어 지기 때문에, 어떤 지역에서도 사용할 수 있다.
//
//번외로 이름없는 메모리 영역을 만들 수 있음
//이름없이 그냥 선언
//{
//
//}  규칙은 함수의 메모리 영역과 같다.
