#include <iostream>

int main()
{
	int a = 0;
	int b = 0;

	b = std::rand();
}
//
//경로 및 함수 변수 한글 절대 금지
//바탕화면 절대 금지 바탕화면에 프로젝트가 있는 걸 확인했을 시 평가에 반영하겠음
//
//
//함수는 실행시킬 때 외부에서의 값을 복사해서 받을 수 있다.
//(main함수 안에서 실행 된 함수라면 스택이 쌓이는 형식인데 스택은 뒤에서 부터 쌓이기 때문에
//	메모리 위치는 main함수보다 무조건 앞에 있다.)
//
//	함수의 리턴값 쪽에 자료형을 넣는 것과 아닌 것의 차이에 대해서 알아보자
//
//	int Left = 1;
//int Right = 1;
//int Result = 0;
//
//리턴값이 무엇이냐 ?
//리턴이라는 용어가 무엇이냐 ?
//
//Left + Right; 는 몇 byte인가 ?
//8바이트지만 사실 12바이트이다.
//
//왜냐
//
//프로그램은 무언가 존재한다면 공짜가 아니라 무조건 위치가 있어야 한다.
//어디선가 메모리를 차지하고 있어야 한다는 소리다.
//
//코드
//데이터
//힙
//스택
//
//int 혹은 연산자 등등 바로 사용할 수 있는 이 모든 것들은 코드 영역에 이미 존재하는 상태이다.
//무엇이든 존재한다면 메모리를 사용해야하고, 메모리를 사용한다는 말은 위치가 존재한다는 소리다.
//
//Left + Right를 했을 때, 그러면 이 값은 어디에 존재하는가 ?
//이 결과값은 어딘가에 존재하고, 이 값을 Rvalue라고 한다.
//
//Rvalue와 Lvalue가 있다.r은 right, l은 left
//그 이름의 이유는 왼쪽에 올 수 있는 값을 Lvalue타입이라고 한다.
//오른쪽에만 올 수 있는 타입을 Rvalue라고 한다.
//
//왼쪽에 올 수 있는 타입들을 Lvalue Type
//명시적 이름(주소, 번지, 포인터)이 있어서 메모리에 접근이 가능해야 한다.
//
//1 = 20; 이 것이 안되는 이유는 명시적 이름과 위치가 존재하지 않기 때문에 메모리 접근이 안된다.
//어디있는지 모르기 때문에 접근, 수정이 되지 않는다.
//
//따라서 Left + Right는 명시적 이름이 없다.어딘가에 값은 존재 하지만, 특정 메모리에 존재하는게 아니기 때문에
//수정 및 접근이 안된다.
//
//따라서
//int main() {
//
//	int a = 1;
//	int b = 1;
//
//	a + b;
//} 이 함수는 8바이트가 아니라 12바이트를 사용하는 것 이다.
//
//a
//위치 : main실행 스택 안
//크기 : 4바이트
//형태 : 정수
//값 : 1
//
//int Test() {
//
//	return 10;  return이란 ? 만약 리턴할 값이 있다면 그 값을 외부에 리턴하고 함수를 종료한다.
//
//		함수를 종료하라고 명령을 내렸으니 여기 어떠한 명령을 넣든 어차피 도달하지 않고 스코프 끝으로 가서
//		함수의 스택메모리를 삭제시킨다.->함수의 종료란 스택메모리 삭제
//}
//
//a = Test();
//8바이트이다.
//Test()의 메모리에 있는 값을 a에 대입하라 라는 말이다.
//
//void ParametersStart(int Value) {
//	< -인자란 외부의 값을 복사받아서 내부에서 사용하는 것을 의미한다.
//
//		Value = 99999;
//}
//
//ParametersStart(a);
//a ?
//
//a의 값을 복사한 ParametersStart의 value는 9999가 된다.
//인자는 지역변수이다.지역변수이므로 value가 아무리 바뀌여 봤자 함수가 종료되면서 스택메모리에서 사라지고
//값을 복사해준 a의 값은 그대로 존재한다.
//
//함수의 인자는 n개 넣을 수 있다.여러개 넣을 수 있다는 소리다.
//하지만 리턴값은 한 번에 한 개를 초과할 수 없다.
//
//함수 = > 행동
//누군가의 체력을 깎는 행동을 하고 싶다.
//
//-> void Damage(int _Hp, int _Att) {
//
//	1) _Hp = _Hp - _Att;
//
//
//}
//
//int MonsterHp = 100;
//Damage(MonsterHp, 10);
//
//이 몬스터의 hp가 90이 되길 원한다
//하지만 1번의 방법을 사용해선 절대로 MonsterHp의 값이 바뀌지 않는다.
//Damage안의 변수 _Hp는 MonsterHp와는 완전히 다른 복제된 개체이기 때문이다.
//
//프로그래밍에서 a와 b가 같다고 확신할 수 있으려면
//주소가 같아야 한다.
//
//Damage의 hp와 monsterhp는 주소가 다르기 때문에 아무리 값을 바꿔도 영향이 가지 않는다.여기서 포인터가 나오는데,
//
//포인터란 무엇이냐 ? 포인터는 변수의 주소값을 저장하기 위한 변수이다.
//포인터는 포인터를 위한 연산자와 문법이 별개로 존재합니다.
//
//int Value = 0;
//
//int* ValuePtr;
//
//int도 자료형이고
//int* 도 자료형이다.
//
//자료형 뒤에* 을 붙이면 그 변수는 무조건 포인터 자료형이 된다.
//
//어제 했던
//연산자에서 기타 연산자가 있는데
//
//int IntSize = 0;
//
//IntSize = sizeof(int);  int의 byte크기를 알려준다.
//IntSize = sizeof(IntSize); 변수도 된다.
//
//주소값이라고 하는 것은 무조건 정수이다.
//아니 그런데 요즘 램의 크기가 16기가바이트인데 16기가 바이트는 크기가 171억인데 어떻게 정수표현식을 사용해서 값을 표현하냐 ?
//따라서 주소의 정수값은 절대로 4바이트가 아니다.그러면 몇바이트냐 ?
//
//PtrSize = sizeof(int*);
//PtrSize = 8byte 따라서 주소값은 8바이트짜리의 정수이다.
//따라서 포인터 변수의 값은 렘에 위치한 어떤 변수나 메모리의 정수 위치를 저장한다.
//
//포인터는 굉장히 위험한 점이 많기 때문에,
//특정 주소를 담는다는 그러한 위험한 방식을 사용하기 때문에 일반적인 정수와는 다른 문법이 많다.
//메모리의 주소 값을 직접적으로 접근하거나 수정하는 방식은 low - level 언어에서나 되기 때문에
//포인터는 일반적인 대입이 안된다.정수라고 해서 정수를 넣어주면 대입이 되는 것이 아니다.
//
//특정 메모리 영역에 주소값을 리턴해달라는 단항 연산자 *
//int* ValuePtr = Value; 이것은 오류이다. int* 는 번지를 넣어줘야 하는데 일반 값을 넣으니 오류
//정수를 넣는것은 C++문법적으로 막혀있다.
//
//포인터 주소는 16진수 기법으로 표기된다.
//포인터 또한 결국 변수이기 때문에, 자기 자신의 위치와 값 메모리를 가져야 한다.
//
//int value = 0;
//주소 100
//형태 정수형
//값 0
//
//int* valueptr = &value;
//주소 120
//형태 int주소형
//값 100
//
//int** valueptrptr = &valueptr;
//주소 150
//형태 int* 주소형
//값 120
//
//메모리 | value | valueptr | valueptrptr | 이런 식으로 만들어 진다.
//
//프로그래머의 기본적인 능력 디버깅
//수많은 리소스 중에 어떠한 메모리를 수정하고 싶다면 그게 어디에 존재하고 어떻게 값이 이동하는 것인가
//그것을 관리하고 알 수 있는 능력 디버깅 문제해결 능력이다.
//하지만 이 주소라는 개념을 명확하게 이해하지 않는다면 이 능력을 기를 수 없다.
//그럼 주소값을 확인할 수 있는 방법이 무엇이냐 ?
//주소는 결국 8바이트 정수이다.그래서 확인하기 위하여 값에 잠시 저장 해보려고 했지만
//__int64 value = valueptr은 되지 않는다.왜 그러느냐 ? 결국 타입이 달라서 그렇다.
//자료형이 다르면 대입이 되지도 않고, 기본적으로 자료형이 다르면 대입이 되면 안된다 라고 머리속에 항상 상기시켜놔야 한다.
//
//여기서 잠깐 타입으로 넘어가면
//1. 자료형이 다르면 대입이 안되야 한다.
//2. 된다고 하여도 무조건 안되게 하여야 한다.
//3. 그런데 될 때가 있고, 안될 때가 있다.->왜 ? 모든건 바이트 덩어리인데 자료형이 무슨 의미인가.. ? 라는 생각이 c, c++에 있다.
//
////1바이트 문자형 char
////0b00000000
//
////1바이트 논리형 bool
////0b00000000  
//단순하게 보자면 두 자료형은 똑같다.
//
//자료형이 달라서 값이 들어가는게 아니라
//정확하게는 크기가 달라서 들어가는 게 있고, 안 들어가는게 있는 것이다.
//
//쓸꺼면 자료형이 다른데 대입했다->어떤일이 벌어지는지에 대해 내가 정확히 알고 해야한다.
//혹은 안써야 한다.
//
//__int64 = int 된다.
//
//int* = int 안된다.
//
//포인터 자료형과 일반 정수형의 대입이 안되는 이유는
//이런 느슨한 규칙에 몇 안되는 c++에서 강하게 막는 대입법 중 하나여서 그렇다.
//
//일반적으로 자료형은 정식적인 캐스팅이라는 것을 통하여 변경해야한다.
//
//__int64 = int 이러한 형식은 자료형이 다른데 대입이 문법적으로 허용되는 것을 암시적 형 변환이라고 한다.
//하지만 암시적 형변환은 극한의 극한까지 피할것이다.
//자료형이 다르면 정당한 캐스팅을 통해서만 형 변환을 할 것이다.
//
//c스타일의 형 변환이 있고
//c++스타일의 형 변환이 있다.
//명시적 형 변환이라고 합니다.
//
//c스타일 캐스팅
//int Value = 20;
//bool Check = (bool)Value; true
//Value = (int)Check; 1
//
//c++ 참조형과 값형이 있는데,
//포인터와 레퍼런스 등을 참조형이라고 하고
//일반적인 변수는 값형이라고 한다.
//c스타일 형변환은 값형태이다.
//
//C++스타일의 캐스팅
//
//int Value = 10;
//bool Check = static_cast<bool>(Value);
//Value = static_cast<Int>(Check);
//
//값형을 값형으로 바꾸는 게 아니라
//값형 = > 참조형으로 바꾸고 싶다.
//
//int Value = 100;
//int* Ptr = &Value;
//
//__int64 Address = reinterpret_cast<__int64>(Ptr);
//
//포인터의 16진수로 나와야 할 값을 __int64로 바꿔준다.
//
//int MonsterHp = 200;
//
//int* MonsterHpPtr = &MonsterHp;
//
//int* = > int
//내가 가진 번지 값의 값이 된다.
//별을 하나 뺀다.
//int
//* MonsterHpPtr = 50;
//MonsterHpPtr이 가리키는 MonsterHp의 값을 바꿔준다.
//
//nullptr은 0번지입니다.
//nullptr_t형입니다.
//포인터는 어차피 주소값이기 때문에
//주소값을 찾거나 아직 내가 가리킬 대상을 찾지 못한 경우가 존재합니다.
//사용하지 않는 포인터는 0으로 값을 넣어놓자 < -모든 프로그래머가 암묵적으로
//	c스타일로 예전에 어떻게 했는가 int* ptr = 0;
//
//하지만 이제 암묵적으로가 아닌 이제 무조건 해야하는 법이다.
//
//주소값이 0을 가리키는 것은 사용하지 않겠다 라는 것이다.
//프로그램 메모리 크러쉬 1순위인 nullptr 익셉션 null레퍼런스 익셉션
//
//c++은 0은 정수니까 사용하지 않는 포인터 비어있는 포인터라는 의미가 아니라 정수와 혼동되어서 사용되는 것이 옳지 않다고 생각하였다.
//그래서 c++ 11에서 nullptr이라는 상수가 생겼다.
//
//따라서 int* ptr = 0; 이 아니라
//int* ptr = nullptr; 이게 c++ 스타일이다.
//
//void Damage(int* MonsterHp, int _Att) {
//
//}
//
//int main() {
//
//	//레퍼런스는 쉽게 설명해서
//	//상시 *이 붙은 상태로 사용하는 포인터이다.
//
//	int MonsterHp = 100;
//	int* MonsterHpPtr = &MonsterHp;
//
//	*MonsterHpPtr = 300; 이런식으로 바꾸는데
//
//		int& Ref = MonsterHp;
//	Ref = 300; 이런식으로 가능
//}
//
//포인터는 있을수도 있고, 없을수도 있는게 가능 예) 매쉬가 없으면 그 부분이 투명해보임
//하지만 레퍼런스는 무조건 값이 있어야한다.오류가 생김
//
//그래서 사용할 때 방식이 다르다.
//무조건 넣어줘야한다.없으면 안된다 = > 레퍼런스
//있어도 되고, 없어도 된다 = > 포인터
//
//레퍼런스를 사용할때는 절대 무조건 어떤일이 있어도 값이 들어올 때 사용합니다.
//
//int Value0 = 10;
//int Value1 = 20;
//퐁니터는 변경이 가능하다는 사실 때문에
//중간에 자신이 가리키는 대상을 바꿀 수 가 있다.
//
//int* Ptr = &Value0; 이러면 Ptr은 Value0를 가리킨다.
//ptr = &Value1; 이러면 Value1을 가리킨다.
//
//ptr = nullptr이것 또한 된다.
//
//하지만 레퍼런스는 오직 딱 한 번만 초기화된다.
//한 번 초기화 된다면 이제 자신이 가리키는 대상을 변경할 수 없다.
//
//int& Ref = Value0;
//Ref = 1000;
//
//Ref = Value1; < -Value0 값에 Value1이 들어간다.
//	Ref = 1000;
//
//
//몬스터가 100개다
//퀘스트가 100개다 그러면 해결방법도 100개
//
//monster01, 02, 03 이런식으로 절대 안한다.
//
//그냥 int MonsterHps[5];
//이걸 int 배열 형이라고 부릅니다.
//int 형이 아니라 int[]형이다.
//
//메모리는 어떻게 되는가
//[][][][][][][][][][][][][][][][][][][][] 이런 식으로 메모리가 저장되며
//모든 변수는 붙어있게 된다.
//
//초기화는 int MonsterHps[5] = { 11,22,33,44,55 }; 이렇게 해야 한다.
//값을 가져오는 방법
//int MonsterHp1 = MonsterHps[0];
//int MonsterHp2 = MonsterHps[1]; 이런 식으로 가져온다.
//
//이러한 방식은 MonsterHps[0] == int& 와 완전히 같다.
//
//int Monster;
//int* ptr = &Monster;
//
//int& Ref = MonsterHps[0]; 이러한 방식이 된다.
//int와 똑같이 작동한다.
//
//Ref를 수정해도 MosnterHps[0]를 수정하는거고 MonsterHps[0]을 수정해도 수정하는 것이다.
//
//__int64 Address0 = reinterpret_cast<__int64>(&MonsterHps[0]);
//__int64 Address1 = reinterpret_cast<__int64>(&MonsterHps[1]);
//__int64 Address2 = reinterpret_cast<__int64>(&MonsterHps[2]);
//__int64 Address3 = reinterpret_cast<__int64>(&MonsterHps[3]);
//__int64 Address4 = reinterpret_cast<__int64>(&MonsterHps[4]);
//이 주소들은 완전히 이어져있다.
//
//int* int[]
//int* Ptr = MonsterHps;
//배열이 사용할 수 있는 문법은
//포인터도 사용할 수 있습니다.
//포인터의 핵심 연산중 하나인 주소 이동
//타 주소 참조가 가능합니다.
//
//int MonsterHp1 = Ptr[0];
//int MonsterHp2 = Ptr[1];
//int MonsterHp3 = Ptr[2];
//int MonsterHp4 = Ptr[3];
//int MonsterHp5 = Ptr[4];
//
//포인터는 마치 배열처럼 사용할 수 있다.
//
//Ptr + 1 == 100번지 + (sizeof(int) * 1) 번지
//Ptr + 2 == 100번지 + (sizeof(int) * 2) 번지
//Ptr + 3 == 100번지 + (sizeof(int) * 3) 번지
//Ptr + 4 == 100번지 + (sizeof(int) * 4) 번지
//
//__int64 Address0 = reinterpret_cast<__int64>(Ptr + 0);
//__int64 Address1 = reinterpret_cast<__int64>(Ptr + 1);
//__int64 Address2 = reinterpret_cast<__int64>(Ptr + 2);
//__int64 Address3 = reinterpret_cast<__int64>(Ptr + 3);
//__int64 Address4 = reinterpret_cast<__int64>(Ptr + 4);
//
//아래는 위 처럼 작동한다.
//
//int* 정수 -> int* 가 나온다.
//
//int MonsterHp1 = Ptr[0];
//int MonsterHp2 = Ptr[1];
//int MonsterHp3 = Ptr[2];
//int MonsterHp4 = Ptr[3];
//int MonsterHp5 = Ptr[4];
//
//int MonsterHp1 = *(Ptr + 0);
//int MonsterHp2 = *(Ptr + 1);
//int MonsterHp3 = *(Ptr + 2);
//int MonsterHp4 = *(Ptr + 3);
//int MonsterHp5 = *(Ptr + 4);
//
//완전히 동일한 방식이다.
//
//하지만 포인터는 배열이 아니다.
//
//int* Ptr = MonsterHps;
//
//sizeof(Ptr)과 sizeof(MonsterHps)는 크기가 다르다
//자료형이 다르기 때문에 서로 다른 것이 맞다.
//
//
//
//
//
//
//
//
//
//
//
//
//
//Rvalue와 Lvalue의 차이는 ?
//Lvalue만 수정할 수 있는 이유는 ?
//return이란 무엇인가
//매개변수로 받은 값을 수정해도 인자의 원본의 값이 수정되지 않는 이유
//포인터 변수의 크기
//* 변수 * *변수 일반 변수 선언, 주소, 형태, 값 설명
//자료형의 캐스팅, 형 변환
//값과 값끼리 캐스팅 하는 방법
//값과 참조형끼리 캐스팅하는 방법
//함수의 인자로 포인터 변수를 보내 인자로 보내준 값의 원본의 값을 바꾸는 방법
//nullptr이란
//nullptr 익셉션, null 레퍼런스 익셉션
//포인터 레퍼런스 차이
//포인터 배열처럼 연산하는 방법
//
//과제
//매개변수로 받은 인자들의 주소 확인해보기
//
////
//
//#include <iostream>
//
//void Test(int _Value0, int _Value1, int _Value2, int _Value3) {
//	int* Addresses[4] = { &_Value0,&_Value1 ,&_Value2 ,&_Value3 };
//	__int64 Address0 = reinterpret_cast<__int64>(Addresses[0]);
//	__int64 Address1 = reinterpret_cast<__int64>(Addresses[1]);
//	__int64 Address2 = reinterpret_cast<__int64>(Addresses[2]);
//	__int64 Address3 = reinterpret_cast<__int64>(Addresses[3]);
//}
//
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = 3;
//	int d = 4;
//	Test(a, b, c, d);
//
//}
//
//
//
