// IfAndFor.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

int StringCount(char* _Ptr) {
	int Count = 0;
	while (_Ptr[Count]) {
		++Count;
	}
	return Count;
}

void StringReverse(char* _Ptr) {
	int Length = StringCount(_Ptr);
	char Temp = 0;

	for (int i = 0; i < Length / 2; ++i)
	{
		Temp = _Ptr[Length - i - 1];
		_Ptr[Length - i - 1] = _Ptr[i];
		_Ptr[i] = Temp;
	}

}


int main()
{
	char Arr[10] = "abc";

	if (Arr[3] == Arr[7]) {
		printf("aa");
	}

	int result = StringCount(Arr);
	StringReverse(Arr);
	int i = 0;
	for (
		 i = 0;
		i < 10;
		++i
		) {

		if (0 != i % 2) continue;

	}

}

//git 변경 내용에서
//
//M = > 수정된 항목이다.
//D = > 삭제된 항목이다.
//A = > 추가된 항목이다.
//
//여태까지 배워왔던 것이 매우 중요하다.
//왜나하면 실제 게임은 조건문으로 만든다고 말할 수 있을 정도이기 때문입니다.
//
//뭐든지 조건에 걸린다면 무엇을 하게 된다.
//
//HP = 0 = > 무엇을 한다.예) 사망 애니메이션을 띄운다.
//물건을 사려고 하는데 돈이 모자르다면 ? = > 무엇을 한다.예) 경고창을 띄운다.
//돈이 충분하다면 ? = > 무엇을 한다 예) 인벤토리로 물건을 옮긴다.
//
//HP, 돈과 같은 명사 곧 변수란 ? = > 메모리 영역이다.램의 x위치에서 y크기로 존재하는 영역을 메모리 영역이라고 한다.
//
//int Hp = 100;
//
//if (/*메모리 영역*/) {
//	실행 코드
//}
//
//메모리 영역을 검사해서 참이면 실행코드를 실행 시키고, 참이 아니라면 실행코드를 실행시키지 않는다.
//메모리 영역에 - 10이 들어와도, 10이 들어와도 0이 아니므로 참이다
//따라서 실행코드가 작동된다.
//
//int GetHp()
//{
//	return 10;
//}
//
//
//if (GetHp(()) {
//	플레이어는 살아있다.
//		int a = 0;
//}        따라서 이것 또한 가능하다.
//
//대신 if는 함수 안에서만 사용 가능하다.
//즉 함수의 실행 메모리에서만{}여기서만 사용할 수 있기 때문이다.
//함수 밖은 메모리 영역이 없으니까 주질 못한다.
//
//if는 보통 비교 연산자와 많이 사용 됩니다.
//== 는 잘 사용하지 않는다.값이 완전히 같을 경우가 적기 때문이다.
//
//참고로 if (Hp += 10, 0 >= Hp) 이런 식으로도 가능하지만 잘 사용하지 않는다.
//
//
//조건을 연계해야 할 때가 있습니다.
//Hp가 100 % 이라면 정상
//Hp가 100 ~50 % 이라면 부상
//Hp가 50 % ~10 % 라면 중상
//Hp가 10 % 미만이라면 사망 직전
//Hp가 0 이하 사망
//
//Hp = 75;
//	if (100 <= Hp) {
//		int a = 110;
//	}
//
//	위 조건의 if가 false라면
//	else if (Hp >= 50) {
//		어차피 위쪽에서 false 이므로 Hp가 무조건 100 이하이다.
//			int a = 0;
//	}
//
//	else if (Hp >= 10) {
//	else if는 여러개를 사용할 수 있다.
//		int a = 0;
//	}
//
//	else if (Hp >= 1) {
//	else if는 여러개를 사용할 수 있다.
//		int a = 0;
//	}
//
//	else {
//		모든 조건이 전부 다 실패했다면 else로 들어옵니다.
//
//	}
//
//	좋지 않은 방법
//
//		if
//			if
//				if
//					if
//						if
//							이 방법은 아주 좋지 않다.
//
//							if
//							else if
//							else if
//							else if
//								이 방법이 훨신 좋은 방법
//
//								또한 최악의 실수
//								int Damage = 200;
//	if (Damage >= 300);   <=== 세미콜론 if문 스코프로 가지 않고 그냥 if가 끝나버린다.
//	{
//		따라서 여기 있는 코드는 무조건 실행되는 코드가 된다.
//	}
//
//	중괄호 삭제하고 치는거 지향하자
//		if (a > 10)
//			a = 0;
//
//	{} 새로운 스택 영역을 만들어라 라는 소리인데
//		저렇게 쓰면 헷갈린다.
//
//		switch는 다음과 같이 사용하고,
//		switch문은 완전히 if문으로 대체될 수 있습니다.
//
//		int A = 10;
//
//	switch (A) {
//	case 0:
//		break;
//
//	case 10:
//		break;
//
//		default;
//		break;
//
//		그런데
//			switch 문에서는 일반적으로 지역변수를 사용할 수 없다.
//	case 상수: 의 조건과 같다면
//
//				if (10 == A) {}
//				else {}
//
//	case 10:  이 두 부분은 의미가 완전히 같다.
//		break;
//
//	default:
//		break;
//
//		switch 메모리 == 상수 밖에 안된다.
//			메모리에 있는 상수가 오른쪽에 같은가
//			<, > 이런 것이 안된다는 소리이다.
//
//			지역변수를 사용하고 싶다면
//	case 10:
//		{
//			int a = 0;
//			break;
//		}
//		이런 식으로 완전히 영역을 잡아주고 사용해야 한다.
//
//			break; 는 switch문에서 탈출하라는 소리다.
//
//
//			char는 1 바이트 문자형인데
//			char Ch = 'A'; ' '안에서 초기화해서 표현해야 합니다.
//
//			case는 상수만 올 수 있는데
//			char T = 'B';
//
//	case T:
//		이런식으로 안된다.변수이므로 비교 대상이 될 수 없다.
//			모든 변수는 case에 비교대상이 될 수 없다.
//
//	case 'a':
//	case 'A':
//		소문자 a와 대문자 A를 구별을 하고 싶지 않다.
//			이런식으로 사용하면 된다.
//
//			이것도 if로 대칭될 수 있다.
//			if (Ch == 'A' || Ch == 'a')
//
//				배열 말고 문자열
//				배열의 한 종류인데
//
//				문자열을 잘 사용(자르거나 붙이거나 다른 문자로 치환하거나) 하는 능력은 기본기라고 생각을 해야 합니다.
//
//				문자열은 세 가지가 있다
//
//				디버깅, 문자열 편집, 파일입출력
//				이 세 가지는 항상 겪게 되는데, 이것을 제대로 이해하고 있다면 프로그래밍 인생이 아주 편해진다.
//				따라서 이 세 가지는 기본기입니다.
//
//				"AAAAAAAAA" <= 문자열 상수 표현식
//				'A' <= 문자의 상수 표현식
//
//				문자열은 굉장히 예외가 많은데, int Arr[5] = { 10,20,30,40,50 } 이거 가능하다.
//				참고로 int Arr[5] = { 10, } 이런식으로 하면 생략하면 나머지는 0으로 채워진다.
//				하지만 int Arr[5]; 는 다르다.
//
//				char String[5] = "AAAA"; 배열과 다르게
//				char String0[5] = { 'A','A','A','A',0 }; 이런식으로 하지 않아도 된다.
//				그런데 위와 아래의 원소가 다른데 이게 무엇이냐 ?
//				문자 처리의 규칙이 있는데, 마지막에는 무조건 0을 넣어줘야 한다는 규칙이 있고, String안에는 마지막에 0이 들어가 있는 것이다.
//				따라서 A A A A 0 이렇게 들어있는 것이다.
//				String과 String0을 출력하면
//				String은 AAAA가 출력되고 String0은 AAAAA!# ^ @#$ % 막 이런 식으로 나오는데
//				printf_s의 핵심은 내부에서 0이 나올 때 까지 글자를 출력한다는 의미이고
//				따라서 String0이 이상하게 출력되는 이유는 내부에 0이 없으므로 계속 출력이 되는 것이다.하지만 값이 할당되지 않았기에
//				쓰레기 값이 나오는 것 이다. 0이 없어서 렘 안에 있는 배열 뒤쪽의 값을 계속 계속 출력하다가 우연하게도 0을 만나기 전 까지
//				출력되는 것이다.
//				이러한 메모리 에러는 최악이다 무조건 조심해야합니다.
//				당연하게도 이러한 이유와 비슷한 이유로 5개 메모리만 선언했으면 5개만 쓰자
//
//				간단하게 복습해볼 내용인데,
//				모든건 위치와 크기가 있다. <=> 모든건 존재해야 한다. <=> 공짜는 없다.어디선가 메모리를 사용했다.
//				여기서 위치와 크기는 램에서의 위치와 크기를 말한다.
//
//				내가 제어할 수 있는 부부 외의 부분에 대해서 신경 쓸 필요가 없다.
//				배열을 5개짜리를 만들었다면 6개짜리를 신경 쓸 이유가 없다.
//				문자열일 경우에 그러면 5byte만 확실히 알고 있으면 된다.
//				그 배열의 6번째 7번째는 ? ? 의 영역이고 사용해서도 안된다.
//
//				while문은 반복문 계열로서
//				while (true) {
//					실행코드
//				}
//		if문과 비슷해 보이지만 다르다.
//
//			if (메모리 영역) {
//				실행 코드
//			}
//
//		while (메모리 영역)문은 메모리 영역의 조건이 참이라면
//
//			while (true) {
//				실행코드
//			}
//
//		실행코드를 한 번 실행하고, 다시 조건문으로 들어간다.
//			따라서 위와 같이 조건문이 거짓이 될 일이 없다면 무한히 반복하므로
//			항상 빠져나올 방법을 만들어놔야 한다.
//
//			int Count = 5;
//
//		while (Count)
//		{
//			putchar('A');
//			Count = Count - 1;
//		}
//
//		if문과 같이 이렇게 할 수는 있는데, 잘 안쓴다.
//			while (Count = Count - 1, Count) {
//
//			}
//
//		문자는 1바이트 문자형이기는 하지만
//			문자 = > 숫자 참과 거짓이 구분되고, 다음과 같은 코드를 사용할 수 있다.
//			'A' = 65
//
//			함수의 인자로 정적 배열을 사용할 수 없다.
//			정적배열이란->상수로 배열의 크기가 정해진 배열을 말한다.
//			그래서 포인터로
//			char String1[5] = { 'A','A','A','A','A' };
//
//		void MyPrintf(char* _Ptr) {
//			int Count = 0;
//			while (_Ptr[count])
//				char Ch = _Ptr[Count];
//			putchar(static_cast<int>(Ch));  //캐스팅을 해주는 이유는 putchar의 인수는 int이다.
//			Count = Count + 1;
//		}
//		While은 생겼다가 사라졌다가 생겼다가 사라졌다가를 반복한다.
//
//			do while이라는 반복문도 있는데,
//
//				일반적인 while문 순서
//				조건문
//				실행코드
//				조건문
//				실행코드 식의 형식이다.
//
//				do while문의 순서
//					실행코드
//					조건문
//					실행코드
//					조건문 식의 형식이다.
//
//					int Count = 5;
//		do {
//			count = count - 1;
//		} while (count);
//
//
//		-= += 복합 할당 연산자
//			++ --전치 후치 증감문
//
//
//			int Plus(int& _Left, int& _Right) {
//			return _Left + _Right;
//		}
//		+ 는 이런 식으로 되는데,
//
//			너무나도 많이 사용하고, 코드가 간결해지기 때문에 등장한게
//			+=
//
//			void Plus(int& _Left, int _Right) {
//			_Left = _Left _Right;
//		} 이런 식으로 작동
//
//			++Value;
//		Value++;
//
//		int PPFirst(int& _Value) {
//			_Value = _value + 1;
//			return _Value;
//		}
//
//		int PPBack(int& _Value) {
//			int Result = _Value;
//			_Value = _Value + 1;
//			return Result;
//		}
//
//		전위를 권장하고, 전위가 메모리적으로 낫다.
//
//
//			for문
//
//			for (
//				int i = 0; // 초기화문
//				i < 10;  //조건문
//				++i  //증감문
//				)
//			{
//				putchar('A');
//			}
//
//		초기화문 실행되고
//			조건문 실행되고
//			실행코드 실행되고
//			증감문 실행되고
//
//			조건문 실행되고
//			실행코드 실행되고
//			증감문 실행되고
//
//			조건문 실행되고
//			실행코드 실행되고
//			증감문 실행되고
//
//			초기화문은 한 번만 실행되고
//
//			while문인데 어떠한 변수를 초기화하는 초기화문과 그 변수를 증감시키는 증감문이 합쳐진 형태이다.
//
//			pinrtf_s();
//		extern "C" C 스타일로 컴파일을 해라.
//			inline
//			int 리턴값
//			__cdecl
//			printf_s
//			(
//				const char* _Format,
//				...
//			);
//
//		printf는 c에서 사용하던 출력 함수입니다.
//			그래서 내부 내용이 c스타일로 짜여져 있다.
//			extern "C"는 이 부분의 컴파일 C 스타일로 컴파일 해줘
//
//			inline
//			가장 빠른 코드는 main()에 있는 코드이다.
//			왜냐하면 함수가 실행되면 메모리를 사용하기 때문이다.
//
//			inline은 함수는 컴파일러의 판단 하에
//			이걸 그대로 복사해서 넣을 수 있다면
//			함수를 제거하고 함수의 내부 내용을 복사해서
//			실행 장소에 붙여넣기 해준다.
//			inline ? 치환이다.
//
//			 중단점은 정말 습관처럼 걸어야 한다.
//			
//			for문이나 while문 안에서 break를 본 적이 있을텐데
//			즉시 반복문을 종료하라는 뜻이다.
//			
//			continue는
//			예) i가 짝수일 때만 무언가를 하고싶다
//			
//			for (int i = 0; i < 10; ++i) {
//				if (0 != (i % 2)) {
//					나머지가 0이 아니면 홀수라는 것 이므로
//						continue;       반복문의 처음으로 돌아감
//				}
//			
//			}
//			
//			continue는 while에서 조건문으로 가고 for에서는 증감문으로 바로 간다.

//
//
//
//			if문이란 ?
//			if문을 함수 안에서만 실행 시킬 수 있는 이유
//			else if란 ?
//				switch문이란 ?
//				switch문에서 break 란 ?
//				switch에서 case의 비교대상으로 될 수 있는 것은 ?
//				배열 초기화
//				문자열의 끝에는 뭐가 들어있는가 ?
//				printf의 출력 방법
//				문자열에서 메모리 에러가 일어나는 원인과 이유
//				현재 값을 한 번 받아보는 습관을 들이자
//				while의 작동 방식은 ?
//				do while문의 순서
//					-= += 복합 할당 연산자
//					++ --전치 후치 증감문
//					for문
//					printf_s 치환
//
//					문제
//					StringFunction001
//					두 가지 함수를 만들기
//
//					int StringCount(char* _Ptr) {
//
//					return;
//
//				}
//
//		int StringReverse(char* _Ptr) {
//
//			return;
//		}
//
//		int main() {
//			char Arr[10] = "ABCD";
//			StringCount(Arr); 넣으면 4가 나오게
//				StringReverse(Arr); DCBA가 출력 되게
//		}
